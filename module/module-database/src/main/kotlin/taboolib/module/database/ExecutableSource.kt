package taboolib.module.database

import taboolib.common.platform.function.warning
import taboolib.common.util.unsafeLazy
import java.sql.PreparedStatement
import java.sql.ResultSet
import java.sql.SQLException
import java.sql.Statement
import javax.sql.DataSource

/**
 * @author sky
 * @since 2021/6/23 2:02 下午
 */
@Suppress("SqlSourceToSinkFlow")
open class ExecutableSource(val table: Table<*, *>, var dataSource: DataSource, val transaction: Boolean) {

    var autoGeneratedKeys = Statement.RETURN_GENERATED_KEYS

    /** 结果处理器 */
    internal val processors = ArrayList<ResultProcessor>()

    /** 数据库连接 */
    internal val connection by unsafeLazy {
        dataSource.connection.also { connection ->
            if (transaction) {
                connection.autoCommit = false
            }
        }
    }

    /** 创建表 */
    open fun createTable(checkExists: Boolean = true) {
        if (table.name.isBlank()) error("Table name is blank")
        executeUpdate(table.generateCreateQuery(checkExists))
        // 创建表的同时创建索引
        table.indices.forEach { createIndex(it) }
    }

    /** 创建索引 */
    open fun createIndex(index: Index) {
        if (table.name.isBlank()) error("Table name is blank")
        table.generateCreateIndexQuery(index)?.also { executeUpdate(it) }
    }

    /** 选择数据 */
    open fun select(func: ActionSelect.() -> Unit) {
        val action = ActionSelect(table.name).also(func)
        executeQuery(action.query, action)
    }

    /** 更新数据 */
    open fun update(func: ActionUpdate.() -> Unit = {}) {
        val action = ActionUpdate(table.name).also(func)
        executeUpdate(action.query, action)
    }

    /** 删除数据 */
    open fun delete(func: ActionDelete.() -> Unit = {}) {
        val action = ActionDelete(table.name).also(func)
        executeUpdate(action.query, action)
    }

    /** 插入数据 */
    open fun insert(vararg keys: String, func: ActionInsert.() -> Unit = {}) {
        val action = ActionInsert(table.name, arrayOf(*keys)).also(func)
        executeUpdate(action.query, action)
    }

    /** 插入数据 */
    open fun insert(keys: List<String>, func: ActionInsert.() -> Unit = {}) {
        val action = ActionInsert(table.name, keys.toTypedArray()).also(func)
        executeUpdate(action.query, action)
    }

    /** 执行查询语句 */
    open fun executeQuery(query: String, action: Action? = null): ResultProcessor {
        return ResultProcessor(query, object : Executable<ResultSet> {
            override fun <C> invoke(func: ResultSet.() -> C): C {
                return try {
                    connection.prepareStatement(query, autoGeneratedKeys).use { statement ->
                        action?.elements?.forEachIndexed { index, any -> statement.setObject(index + 1, any) }
                        statement.executeQuery().use { func(it) }.also { action?.callFinally(statement, connection) }
                    }
                } catch (ex: SQLException) {
                    warning("Query: $query")
                    warning("Parameters (${action?.elements?.size ?: 0}): ${action?.elements}")
                    throw ex
                }
            }
        }).also { processors += it }
    }

    /** 执行更新语句 */
    open fun executeUpdate(query: String, action: Action? = null): ResultProcessor {
        return ResultProcessor.Update(query) {
            try {
                connection.prepareStatement(query, autoGeneratedKeys).use { statement ->
                    action?.elements?.forEachIndexed { index, any -> statement.setObject(index + 1, any) }
                    statement.executeUpdate().also { action?.callFinally(statement, connection) }
                }
            } catch (ex: SQLException) {
                warning("Query: $query")
                warning("Parameters (${action?.elements?.size ?: 0}): ${action?.elements}")
                throw ex
            }
        }.also { processors += it }
    }

    /**
     * 保存更改，需要启用事务模式
     * 如果保存失败则会回滚
     */
    open fun saveChanges(): Result<Unit> {
        // 使用 autoCommit 的同时也可以判断是否成功取到了连接
        return if (!connection.autoCommit) {
            try {
                // 执行所有的处理器
                processors.forEach { it.run() }
                // 提交事务
                connection.commit()
                Result.success(Unit)
            } catch (e: SQLException) {
                // 回滚事务
                try {
                    connection.rollback()
                } catch (ex: Throwable) {
                    ex.printStackTrace()
                }
                Result.failure(e)
            } finally {
                connection.close()
            }
        } else {
            error("transaction is not enabled")
        }
    }

    /**
     * 关闭链接
     */
    open fun close() {
        connection.close()
    }

    /**
     * 生成数据表创建语句
     */
    open fun Table<*, *>.generateCreateQuery(checkExists: Boolean = true): String {
        if (columns.isEmpty()) {
            error("empty column")
        }
        val stat = Statement("CREATE TABLE")
        stat.addSegmentIfTrue(checkExists) {
            addSegment("IF NOT EXISTS")
        }
        stat.addSegment(name.asFormattedColumnName())
        stat.addSegment("(")
        // 列表
        stat.addSegment(columns.joinToString { it.query })
        // 主键
        stat.addSegmentSequence(prefix = ", ") {
            // 主键
            addSegmentIfTrue(primaryKeyForLegacy.isNotEmpty()) {
                addSegment("PRIMARY KEY")
                addKeys(primaryKeyForLegacy.toTypedArray())
            }
            // 索引
            addSegment(columns.asSequence()
                .filterIsInstance<ColumnSQL>()
                .filter { it.options.contains(ColumnOptionSQL.KEY) }
                .groupBy { it.indexType }
                .map { (key, value) ->
                    Statement()
                        .addSegment("KEY `idx_${value.joinToString("_") { it.name }}`")
                        .addSegment("(${value.joinToString { "${it.name.asFormattedColumnName()} ${if (it.desc) "desc" else ""}".trim() }})")
                        .addSegmentIfTrue(key != IndexType.DEFAULT) {
                            addSegment("USING $key")
                        }.build()
                }.joinToString()
            )
            // 唯一索引
            addSegment(columns.asSequence()
                .filterIsInstance<ColumnSQL>()
                .filter { it.options.contains(ColumnOptionSQL.UNIQUE_KEY) }
                .groupBy { it.indexType }
                .map { (key, value) ->
                    Statement()
                        .addSegment("UNIQUE `uk_${value.joinToString("_") { it.name }}`")
                        .addSegment("(${value.joinToString { "${it.name.asFormattedColumnName()} ${if (it.desc) "desc" else ""}".trim() }})")
                        .addSegmentIfTrue(key != IndexType.DEFAULT) {
                            addSegment("USING $key")
                        }.build()
                }.joinToString()
            )
        }
        stat.addSegment(")")
        return stat.build()
    }

    /**
     * 生成索引创建语句
     */
    open fun Table<*, *>.generateCreateIndexQuery(index: Index): String? {
        if (host is HostSQL && index.checkExists) {
            val sql = "select count(*) from information_schema.STATISTICS where table_schema = DATABASE() and TABLE_NAME = ? and INDEX_NAME = ?"
            ResultProcessor(sql, object : Executable<ResultSet> {
                override fun <C> invoke(func: ResultSet.() -> C): C {
                    return try {
                        connection.prepareStatement(sql, autoGeneratedKeys).use { statement: PreparedStatement ->
                            statement.setString(1, table.name)
                            statement.setString(2, index.name)
                            statement.executeQuery().use { func(it) }
                        }
                    } catch (ex: SQLException) {
                        warning("Query: $sql")
                        warning("Parameters (2): [${table.name},${index.name}]")
                        throw ex
                    }
                }
            }).also { processors += it }.first {
                return@first getInt(1) == 1
            }.also {
                if (it) {
                    return null
                }
                index.checkExists = false
            }
        }
        return Statement("CREATE")
            .addSegmentIfTrue(index.unique) {
                addSegment("UNIQUE")
            }
            .addSegment("INDEX")
            .addSegmentIfTrue(index.checkExists) {
                addSegment("IF NOT EXISTS")
            }
            .addSegment(index.name)
            .addSegment("ON")
            .addSegment(table.name)
            .addSegment("(")
            .addSegment(index.columns.joinToString(",", transform = { it.asFormattedColumnName() }))
            .addSegment(")")
            .build()
    }
}
